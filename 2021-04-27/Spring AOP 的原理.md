## 简述 Spring AOP 的原理
### 基本概念
AOP面向切面编程是一种编程范式，联想到面向对象编程（OOP），这种编程方式关注的是切面。基本概念：

- 连接点（JointPoint）：程序中需要横切的地方。连接点可能是执行完一个方法后记录操作日志，或者记录执行耗时，统一异常处理的地方等等；
- 切入点（Pointcut）：一组相关连接点的集合；
- 通知（Advice）：在连接点上执行的行为，增强拓展了AOP需要在连接点处执行的行为。包括前置增强（before advice）、后置增强（after advice）；
- 切面（Aspect）：通知和切入点的结合；
- 织入（Weaving）：一个过程，一个将切面应用到目标对象而创建出目标代理对象的过程；
- 代理（Proxy）：通过代理方式对目标对象应用切面，AOP可以用JDK动态代理或者Cglib实现
- 目标对象（Target）：被代理的对象。

这里的切面是指相对我们代码自上而下执行而言，切面就像一个虚拟的”平面“对程序的某个点进行了横切了一样，不再是自上而下地添加逻辑，而是在一个个切入点把逻辑（通知）横切进去。

### 原理
AOP的原理为动态代理，Spring的动态代理有两种：一是JDK的动态代理；二是Cglib动态代理。

#### JDK的动态代理
需要实现InvocationHandler接口的invoke()方法，在使用时通过Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)方法创建代理对象,变量loader为被代理类的类加载器，变量interfaces为被代理类的接口列表，变量h为代理类（实现了InvocationHandler接口的类）的实例。

优点：

- JDK原生，不需要额外的依赖；
- 通过反射生成代理类的速度比Cglib操作字节码生成代理类的速度更快。

缺点：

- 代理类必须实现接口，否则无法代理；
- 无法为接口中没有的方法实现代理，假如现在有一个实现了接口的实现类，我们为一个不属于接口的方法配置了切面，Spring仍然会使用JDK的动态代理，但是这个切面不会被织入。
- 方法执行时需要通过反射回调，效率比较低。

#### Cglib的动态代理
Cglib底层采用了ASM字节码生成框架，可以直接对类的字节码进行操作，直接生成目标类的子类，并重写类所有能重写的方法，重写过程中，将我们定义的逻辑（切面）织入到方法中，对方法进行了增强。

优点：

- 不需要实现接口，以为Cglib生成的代理类是直接继承自被代理类；
- 生成的代理类和我们自己编写并编译的类没有太大区别，方法调用也和普通类一样，所以方法执行效率比JDK动态代理高。

缺点：

- Cglib通过继承生成代理类，如果一个类的final类，无法被Cglib代理；
- Cglib实现代理方法的方式是重写父类的方法，无法代理private和final的方法，这些方法无法被子类重写；
- 生成代理类的方式是操作字节码，生成速度比JDK的动态代理慢。

### 总结
Spring默认使用JDK的动态代理，只有在类没实现接口的时候，才会使用Cglib。
