## 简述 Linux 系统态与用户态，什么时候会进入系统态？
### 内核态
在内核态，执行代码可以不受限制地访问硬件，可以执行任何CPU指令和使用所有的内存地址。用来防止应用程序越权操作，通常只对底层大多数操作系统信任的函数开放。在内核态崩溃（crashes）会导致整个PC宕机。

#### 用户态
在用户态，执行代码没有直接访问硬件和物理地址的权限，必须得到通过系统API访问硬件和物理内存。也得益于这种隔离措施，在用户态崩溃都是可恢复的，不会导致宕机。大多数代码都运行在用户态。

### 什么时候会进入系统态
应用程序无法自由进入内核态，只能通过操作系统提供的API进入，或者中断操作发生的时候进入。

CPU会被中断操作（如定时器（timers），键盘输入，I/O）中断。中断发生后，CPU会停止运行当前他正在运行的程序，切换到内核态，调用中断处理器（interrupt handler）。中断处理器保存CPU状态并执行操作，执行完成后恢复CPU状态并返回给用户态。

### 延伸-为什么要有用户态和内核态
从冯诺依曼体系讲起，计算机最重要的五部分：运算器，控制器，存储器，输入设备，输出设备。其中，运算器是无状态的；控制器配合部分寄存器行动，但是寄存器数量很少；输入、输出设备只有接收到指令的时候才有动作。

所以，整个计算机的运行状态只受存储器和少数几个寄存器控制。也就是说，一段程序能完全控制物理内存，就能做到任意改变计算机的状态，包括干掉整个操作系统把自己变成操作系统；把自己变成操作系统的一部分等等。

因此，物理内存就是整个计算机状态的全部，如果程序有办法读写所有的物理内存和寄存器，那么任何保护手段都无济于事。所以要限制应用程序的行为，必须在应用程序和操作系统执行时有不同的状态。所以核心问题在于保护关键寄存器和物理内存，这就需要虚拟地址空间映射了。

#### 虚拟地址空间映射
虚拟地址空间映射是用来防止应用程序越权访问内存的技术，操作系统配合硬件的MMU共同实现的。在用户态下，应用程序访问的内存地址是虚拟内存地址，会映射到操作系统指定的物理地址上。这个虚拟地址空间就是用户空间（User Space）。