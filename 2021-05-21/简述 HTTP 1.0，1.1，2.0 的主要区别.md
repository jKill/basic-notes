## 简述 HTTP 1.0，1.1，2.0 的主要区别
### 1.1支持Host字段（Host field）
HTTP1.1 需要包含host的头部信息（Host Header），而1.0不需要。如：

```
GET / HTTP/1.1
Host: www.blahblahblahblah.com
```

有了这个头部信息，就可以通过代理服务器传递信息，使得web服务器能区分部署在同一个服务器上的不同网页。比如：你把 taobao.com 和 baidu.com 都指向了同一个 IP。这时你就可以通过Host字段区分哪个的网页是客户端想要的

### 1.1支持长连接（Persistent connections）
HTTP1.1默认支持长连接，可以在同一个HTTP连接上进行多个请求/响应。而1.0每一个请求/响应，都需要打开一个新的连接，然后这个连接在请求/响应结束后就关闭。这样会导致一个大的性能问题，尤其是TCP有慢开始这一特性。
### 1.1支持分块编码（chunked-encoding）
分块编码可以提升动态页面的响应，因为他允许在不知道响应总长度的情况下，发送响应数据。
#### 1.1支持缓存
支持缓存，使得HTTP1.1节省了带宽，提高了响应速度。
#### 1.1支持压缩和解压缩
压缩消息，也实现了节省带宽和提高响应速度的效果。

### 2.0支持HPACK压缩
HTTP1.1使用的GZIP算法，对HTTP消息的压缩效果很好，能大大减小CSS、JS等文件的大小。但是对于HTTP头部，还是以plain text方式发送，没能压缩。2.0采用的HPACK压缩方法，可以消除HTTP标头数据包的多余信息，每个HTTP数据包能少几个字节。考虑到加载一个网页所涉及的HTTP数据包数量，这个优化在性能上的提升很可观。尤其是一些使用了cookie的HTTP请求，头部通常比较大。

### 2.0支持服务端推送（server push）
传统的Web应用，客户端需要发送一个GET请求并收到服务端响应的一个HTML页面，拿到这个页面后才知道自己需要哪些额外的资源（如CSS、JS文件等），然后再向服务端请求一次，拿到这些CSS、JS文件，才能完成整个页面的加载。
##### HTTP1.1的资源内嵌Resource Inlining方案
针对这个问题，HTTP1.1有一个资源内嵌（Resource Inlining）的解决方案。资源内嵌会把CSS、JS等资源合并到HTML文件里一起响应给客户端，这样就可以省下第二次请求了。但是这样会带来以下问题：

- 轻量级是HTML文本的一个优势，如果把CSS、JS等非文本的大文件加进去，会使HTML丧失这个优势。
- 如果HTML与CSS、JS分离，客户端可以缓存自己已有的CSS、JS等。现在混合在一起了，如果几个HTML都用到了同样的JS、CSS文件，客户端要重复接收多次同样的CSS、JS文件，而没法拒绝。

##### HTTP2.0的服务端推送方案
针对资源内嵌的缺点，HTTP2.0的服务推送在返回HTML文档时，不再把整个资源文件（CSS、JS等）加进去，而是加入资源的头部信息。仅仅告诉客户端，接下来要返回什么资源文件即可。客户端可以根据这些头部信息，决定缓存接下来的文件（还没有的情况下）还是拒绝（已有的情况下）。

### 2.0支持多路复用（multiplexing）
多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。
### 2.0支持调整优先级（Prioritization）权重
HTTP2.0，客户端可以调整资源的优先级权重，服务端根据这个权重生成一颗资源树（dependency tree）。这样开发者可以更好地控制页面交互。比如把高清图片的优先级调后，使用一张缩略图（更高优先级）代替。
