## 简述动态代理与静态代理
### 静态代理
代理类通过与被代理类实现同一个接口或者继承被代理类，对被代理类的方法进行增强，附加功能。

假如我有一个Business接口，里面包含一个invoke()方法。业务订单类Order下单流程order()需要加锁，如果我不希望改变order()原有的逻辑，可以通过一个代理类OrderProxy实现接口的invoke()方法，并且持有Order对象，在invoke()方法里调用order()方法，就可以在order()前后进行加锁解锁等增强逻辑。

缺点：

- 代理类和同一类型的被代理类是一一对应的关系，每增加一种需要代理的场景，就要增加一个代理类，加入现在有业务需要实现加锁和解锁的代理，得加一个加解锁代理类；要实现操作日志的代理，又得加一个操作日志代理类......在程序规模稍大之后就很难维护了。
- 代理类和被代理类实现了相同的接口，如果接口增加一个方法，代理类和被代理类都要实现新增的方法，增加了代码维护的难度。

### 动态代理
由于静态代理只能代理一种类型的类，维护不方便，而且项目里一大堆代理类也很不”优雅“。所以大多数场景下，动态代理是更好的选择。比较常见的代理有JDK动态代理和Cglib动态代理。

#### JDK的动态代理
需要实现InvocationHandler接口的invoke()方法，在使用时通过Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)方法创建代理对象,变量loader为被代理类的类加载器，变量interfaces为被代理类的接口列表，变量h为代理类（实现了InvocationHandler接口的类）的实例。

优点：

- JDK原生，不需要额外的依赖；
- 通过反射生成代理类的速度比Cglib操作字节码生成代理类的速度更快。

缺点：

- 代理类必须实现接口，否则无法代理；
- 方法执行时需要通过反射回调，效率比较低。

#### Cglib的动态代理
Cglib底层采用了ASM字节码生成框架，可以直接对类的字节码进行操作，直接生成目标类的子类，并重写类所有能重写的方法，重写过程中，将我们定义的逻辑（切面）织入到方法中，对方法进行了增强。

优点：

- 不需要实现接口，因为Cglib生成的代理类是直接继承自被代理类；
- 生成的代理类和我们自己编写并编译的类没有太大区别，方法调用也和普通类一样，所以方法执行效率比JDK动态代理高。

缺点：

- Cglib通过继承生成代理类，如果一个类是final类，无法被Cglib代理；
- Cglib实现代理方法的方式是重写父类的方法，无法代理被private（隐式final）和final修饰的方法，这些方法无法被子类重写；
- 生成代理类的方式是操作字节码，生成速度比JDK的动态代理慢。