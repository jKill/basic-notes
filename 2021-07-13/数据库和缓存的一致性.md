## 数据库和缓存的一致性
### 策略0：Cache Aside

- 对于不改变数据的操作（读）：缓存不存在则去DB加载，设置缓存，然后返回。
- 对于改变数据的操作（新增、更新、删除）：**先操作数据库**的数据，然后删除缓存。

虽然Cache Aside策略是事实上的缓存一致性实现，还是存在一些问题。
#### 策略0缺点

- 实时一致性问题：进程A尝试更新数据，它先更新DB，但是在删除缓存之前，进程B读取了缓存。这时候B读到的数据是过时的，但是最终一致性还是能保证的。
- 最终一致性问题-极端情况：极端情况下，最终一致性也不能保证。同样是上面的场景，如果A在删除缓存前被kill掉了，那么过时的缓存数据就会一直存在。
- 最终一致性问题-正常情况：进程C尝试读取缓存，但没有命中，于是C回去DB读取。读取到数据，在正要设置缓存的时候，C发生了停顿（因GC、OS调度等）。这时候进程D更新了这个数据，然后删除缓存。然后C终于恢复运行，把自己从DB加载的数据设置到缓存中，但是这个数据是过时的。

#### 策略0的最终一致性-正常情况的进一步分析

- 正常情况下的最终一致性问题，只有在C没命中缓存的时候才发生。但是如果C和D要操作的数据属于热数据，那么在缓存过期后应该很快就会被重新设置。如果属于冷数据，那么两个进程同时对它进行读和更新的概率很低。
- 大多数时候，写Redis比写DB快得多。在D更新DB数据之前，C就已经把缓存设置好了。

总的来说，正常情况下Cache Aside是可以保证最终一致性的。
### 策略1：Cache Aside变体1

- 对于不改变数据的操作（读）：缓存不存在则去DB加载，设置缓存，然后返回。
- 对于改变数据的操作（新增、更新、删除）：**先删除缓存**，然后操作数据库。

#### 策略1缺点
策略1有很明显的问题，连最终一致性也不能保证，并且发生概率比策略0高。考虑以下场景：

- 假设进程A删除了缓存，正准备更新DB。
- 这时进程B由于缓存miss（被A删除了），而去DB加载数据（此时DB还没被A更新），并设置缓存。
- A开始更新DB。这样一来，缓存的数据和DB不一致了。

### 策略2：Cache Aside变体2

- 对于不改变数据的操作（读）：缓存不存在则去DB加载，设置缓存，然后返回。
- 对于改变数据的操作（新增、更新、删除）：先操作数据库，然后**对缓存做同样的操作（新增、更新或删除）**。

#### 策略2缺点
策略2的问题也很明显，同样发生概率也比策略0高。考虑以下场景：

- 如果进程A、B都要更新数据。
- A比B先更新DB，但是B在A之前更新了缓存。
- 然后A也更新缓存，导致缓存和数据库不一致。

### 策略3：Read Through 和 Write Through
把向DB读写数据都交给缓存层，客户端则只和缓存层交互。

- Read Through：仅仅请求缓存层。
- Write Through：客户端只需要操作缓存，缓存层自动和DB进行同步。

#### 策略3缺点

- 很多缓存层都不支持自动与DB同步。
- 流行的缓存中间件，如Redis并不是RDBMS（关系型数据库），不保证数据可靠（除非牺牲性能，每次操作都fsync，但是这样就失去了用缓存的意义）。

### 策略4：Read Through 和 Write Behind

- Read Through：仅仅请求缓存层。
- Write Behind：客户端只需要操作缓存，缓存层把数据保存到消息队列后就返回成功。消息队列异步把操作同步到数据库。

#### 策略4优点：

- 异步操作能极大提高吞吐量。
- 高度持久化的消息队列很容易实现，如Redis stream (从Redis 5.0开始支持)就很适合。

#### 策略4缺点：

- 很多缓存层不支持
- 消息队列需要严格保证先进先出，否则DB数据会出错。

### 策略5：延时双删（Double Delete）

- 对于不改变数据的操作（读）：缓存不存在则去DB加载，设置缓存，然后返回。
- 对于改变数据的操作（新增、更新、删除）：1、删除缓存；2、然后操作数据库；3、短暂Sleep(如500ms)；4、再次删除缓存。

#### 策略5 优点

- 合并了策略0和策略1，正常场景下保证了最终一致性。（停顿500ms是为了等待其他在读数据的进程把旧数据在Redis保存完毕，然后第二次删除会清除这些脏数据）。

### 策略6： Write Behind变体1（阿里巴巴）

不是直接同步DB到缓存，而是通过**订阅MySQL的binlog**，实现DB到Redis的同步。

#### 策略6优点：

- binlog是一个RDMS技术，是可持久化，可以认为即使发生disaster也可以自行恢复。
- binlog在MySQL和主从同步之间，已经有很成熟的应用了。