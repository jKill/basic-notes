## JMM 中内存模型是怎样的？什么是指令序列重排序？
### 指令重排序
指令重排序的原因很多，如：

- 操作系统底层机制对线程的不同处理；
- JIT编译器的优化；
- 处理器对代码的优化。

#### 指令重排序的解决方案
编程中，需要防止可能影响程序正确性的指令重排序，Java中的方法如：

- 使用synchronized关键字对代码进行同步。
- 借助volatile附带的内存屏障。

### Java内存模型（JMM）
Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存。线程对变量的所有操作（读、写）都要在各自的工作内存中进行，不能直接读写主内存、其他线程工作内存中的变量。线程之间变量的值传递都要经过主内存完成。

### 总线锁
多CPU下，其中一个处理器要对共享内存进行操作时，在总线上发出一个LOCK#信号，这个信号使得其他处理器无法通过总线访问共享内存的数据。但是这样代价太大了，引入了缓存锁降低锁的粒度。

### 缓存锁
缓存锁基于缓存一致性协议，一个处理器的缓存写回到内存会导致其他处理器的缓存无效，因此IA-32和Intel64使用MESI实现缓存一致性协议。

### MESI
MESI是一种较常用的缓存一致性协议，对CPU内的数据规定了四种状态：

- M(Modify)共享数据只缓存在当前CPU中，并且是修改状态，也就是缓存数据和主内存数据不一致；
- E(Exclusive)表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改；
- S(Shared)表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存中的数据一致；
- I(Invalid)表示数据已经失效。

对于MESI协议，从CPU角度来说会遵循：

- CPU读请求，只能读M、E、S状态的缓存，I状态只能从主内存读取；
- CPU写请求，缓存处于M、E状态才可以写，S状态需要将其他CPU的缓存置为无效才能写。

#### MESI带来的问题
各个CPU缓存行的状态是通过消息来传递实现的。如果CPU0要对一个缓存中共享的变量进行写入，需要首先发一个失效的消息给到其他缓存了该数据的CPU。并且要等到他们的确认回执。CPU在这段时间都处于阻塞状态，为了避免阻塞带来的资源浪费，CPU又引入了store bufferes：要写入共享数据时，写把数据写入store bufferes，同时发送invalidate消息，然后继续处理其他指令（异步）当收到其他所有CPU发送的invalidate acknowledge消息后，将store bufferes存储到缓存行，再从缓存行同步到主内存，但是这种优化会带来可见性和指令乱序执行问题。所以CPU层面提供了内存屏障，可以在适当的地方插入内存屏障，禁止指令重排序。在Java中，这个内存屏障由volatile关键字提供。


