## JVM 中内存模型是怎样的，简述新生代与老年代的区别？
#### 新生代和老年代
新生代存储的对象大多存活时间比较短，很快会被回收或者晋升到老年代。适合使用复制算法回收，只需要复核少量的存活对象，然后清理就可以了。

老年代大小通常比新生代大，对象存活时间也比较长。

对象优先在新生代的Eden区分配，大对象通常会直接分配到老年代。长期存活的对象也会进入老年代。

#### Java内存模型
Java内存模型规定了所有变量都存储在主内存中，每条线程还有自己的工作内存。线程对变量的所有操作（读、写）都要在主内存中进行，不能直接读写主内存、其他线程工作内存中的变量。

- 总线锁

多CPU下，其中一个处理器要对共享内存进行操作时，在总线上发出一个LOCK#信号，这个信号使得其他处理器无法通过总线访问共享内存的数据。但是这样代价太大了，引入了缓存锁降低锁的粒度。

- 缓存锁

缓存锁基于缓存一致性协议，一个处理器的缓存写回到内存会导致其他处理器的缓存无效IA-32和Intel64使用MESI实现缓存一致性协议。

- MESI

MESI是一种较常用的协议，有四种状态：

1、M(Modify)共享数据只缓存在当前CPU中，并且是修改状态，也就是缓存数据和主内存数据不一致；

2、E(Exclusive)表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改；

3、S(Shared)表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存中的数据一致；

4、I(Invalid)表示数据已经失效。

对于MESI协议，从CPU角度来说会遵循：

1、CPU读请求，只能读M、E、S状态的缓存，I状态只能从主内存读取；

2、CPU写请求，缓存处于M、E状态才可以写，S状态需要将其他CPU的缓存置为无效才能写。

- MESI带来的问题

各个CPU缓存行的状态是通过消息来传递实现的。如果CPU0要对一个缓存中共享的变量进行写入，需要首先发一个失效的消息给到其他缓存了该数据的CPU。并且要等到他们的确认回执。CPU在这段时间都处于阻塞状态，为了避免阻塞带来的资源浪费，CPU又引入了store bufferes：要写入共享数据时，写把数据写入store bufferes，同时发送invalidate消息，然后继续处理其他指令（异步）当收到其他所有CPU发送的invalidate acknowledge消息后，将store bufferes存储到缓存行，再从缓存行同步到主内存，但是这种优化会带来可见性和指令乱序执行问题。所以CPU层面提供了内存屏障，可以在适当的地方插入内存屏障，禁止指令重排序。在Java中，这个内存屏障由volatile关键字提供。


## volatile 关键字解决了什么问题，它的实现原理是什么？
volatile关键字解决了变量的可见性问题。一个变量被定义成volatile后，各个线程在使用前都先从主内存刷新，从而保证各个线程看到的值一致。但是仅仅保证可见性并不能实现线程安全（可以通过20个线程对同一个变量+5000次，结果小于10W 这个例子证明）volatile不能保证原子性，所以在很多地方，包括JDK源码通常能看到volatile变量和CAS操作（保证原子性）配合使用实现线程安全。

volatile的第二个语义是禁止指令重排优化，加了volatile修饰的变量，在赋值后，JVM会多执行一个lock 前缀的指令，这个指令相当于一个内存屏障（Memory Barrier或Memory Fence）

重排序分3种类型：

1、编译器优化的重排序：编译器不改变单线程程序语义得前提下，重新安排语句的执行顺序；

2、指令级并行的重排序：现代处理器采用了指令级并行技术（ILP），改变不存在是数据依赖的语句；

3、内存系统的重排序处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。

- happens-before规则
表示前一个操作的结果对后一个操作是可见。如果两操作之间存在happens-before关系，那么其中一个操作的结果必须对另一个操作可见。执行这两个操作的可以是同一个线程，也可以是不同的线程。

- JMM的内存屏障
JMM中把内存屏障分成4类：

1、 LoadLoad(load1:LoadLoad:load2)确保load1的数据装载优先load2以及之后的装载指令的装载；

2、 StoreStore(store1:StoreStore:store2)确保store1的数据对其他处理器可见先于store2及之后的存储指令的存储；

1、 LoadStore(load1:LoadStore:store2)确保load1装载的数据优先于store2及后续所有的存储指令刷新到内存；

4、 StoreLoad(store1:StoreLoad:load2)确保store1数据对其他处理器可见先于load2及之后的装载指令的装载，会使屏障之前所有内存访问（存储和装载指令）指令完成后，才执行屏障之后的内存访问指令。同时具有其他3个屏障的效果，但是开销也很昂贵。

- 内存屏障插入策略

1、每个volatile写操作的前面插入一个StoreStore屏障；

2、每个volatile写操作的后面插入一个StoreLoad屏障；

3、每个volatile读操作的前面插入一个LoadLoad屏障；

4、每个volatile读操作的后面插入一个LoadStore屏障；

#### 其他能实现可见性的关键字
- 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把这个变量同步会主内存（store、wirte操作）”这条规则获得的
- final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”发的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象）那么在其他线程中就能看见fianl字段的值