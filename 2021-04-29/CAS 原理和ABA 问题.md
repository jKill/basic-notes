## CAS 原理，什么是 ABA 问题，怎么解决？
### 原理
CAS操作常用于基于乐观并发策略的线程安全机制，但是乐观并发需要”硬件指令集的支持“，因为我们要求冲突检测和操作这两个步骤具有原子性。这里只能通过硬件实现，硬件保证某些从语义看起来需要多次操作的行为可以通过一条处理器指令完成，这类指令包括：

- 测试并设置（Test-and-Set）；
- 获取并增加（Fetch-and—Increment）；
- 交换（Swap）；
- 比较并交换（Compare-and-Swap，即本文的主角CAS）。

CAS指令需要三个参数，内存位置（用V表示），旧的预期值（用A表示）和将要设置的新值（用B表示），当V符合A时，CAS操作才会把V的值更新为B，否则不更新。不管更新成功与否，都会返回V的旧值。这个过程是一个原子操作，执行时不会被其他线程中断。

### ABA问题
ABA问题是CAS的一个逻辑漏洞，如果一个线程p初次读取变量V的时候，读到的值为A，而且准备赋值的时候检查到它还是A。并不能说明V的值在这期间没被改过，可能另一个线程把V改成B，然后又改成A。这样CAS操作会误以为这个值没改变过。

要解决这个问题，可以为内存值加上一个”版本号“，被更新后版本号也随之改变，每次CAS检测冲突的时候，不止检查内存的值，也检查版本号。这个解决方案在Java中的实现是位于JUC包的AtomicStampedReference类，用整型变量stamp来记录版本号，用二元组[reference, integer]实现内存和版本号的冲突检测。