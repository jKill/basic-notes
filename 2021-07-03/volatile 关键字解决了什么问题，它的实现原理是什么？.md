## volatile 关键字解决了什么问题，它的实现原理是什么？
volatile关键字解决了变量的可见性问题。一个变量被定义成volatile后，各个线程在使用前都先从主内存刷新，从而保证各个线程看到的值一致。但是仅仅保证可见性并不能实现线程安全（可以通过20个线程对同一个变量+5000次，结果小于10W 这个例子证明）volatile不能保证原子性，所以在很多地方，包括JDK源码通常能看到volatile变量和CAS操作（保证原子性）配合使用实现线程安全。

volatile的第二个语义是禁止指令重排优化，加了volatile修饰的变量，在赋值后，JVM会多执行一个lock 前缀的指令，这个指令相当于一个内存屏障（Memory Barrier或Memory Fence）

重排序分3种类型：

- 编译器优化的重排序：编译器不改变单线程程序语义得前提下，重新安排语句的执行顺序；
- 指令级并行的重排序：现代处理器采用了指令级并行技术（ILP），改变不存在是数据依赖的语句；
- 内存系统的重排序处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。

### happens-before规则
表示前一个操作的结果对后一个操作是可见。如果两操作之间存在happens-before关系，那么其中一个操作的结果必须对另一个操作可见。执行这两个操作的可以是同一个线程，也可以是不同的线程。

### JMM的内存屏障
JMM中把内存屏障分成4类：

- LoadLoad(load1:LoadLoad:load2)确保load1的数据装载优先load2以及之后的装载指令的装载；
- StoreStore(store1:StoreStore:store2)确保store1的数据对其他处理器可见先于store2及之后的存储指令的存储；
- LoadStore(load1:LoadStore:store2)确保load1装载的数据优先于store2及后续所有的存储指令刷新到内存；
- StoreLoad(store1:StoreLoad:load2)确保store1数据对其他处理器可见先于load2及之后的装载指令的装载，会使屏障之前所有内存访问（存储和装载指令）指令完成后，才执行屏障之后的内存访问指令。同时具有其他3个屏障的效果，但是开销也很昂贵。

### 内存屏障插入策略

- 每个volatile写操作的前面插入一个StoreStore屏障；
- 每个volatile写操作的后面插入一个StoreLoad屏障；
- 每个volatile读操作的前面插入一个LoadLoad屏障；
- 每个volatile读操作的后面插入一个LoadStore屏障；

#### 其他能实现可见性的关键字

- 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把这个变量同步会主内存（store、wirte操作）”这条规则获得的。
- final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”发的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象）那么在其他线程中就能看见fianl字段的值。