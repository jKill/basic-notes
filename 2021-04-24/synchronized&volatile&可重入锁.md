## 简述 Synchronized，Volatile，可重入锁的不同使用场景及优缺点

#### synchronized

- 优点：结构简洁紧凑，有偏向锁、轻量级锁等优化机制，JDK1.6之后性能比ReentrantLock好。
- 缺点：无法响应中断，会导致线程阻塞。
- 使用场景：无需响应中断，实现定时等场景，synchronized都应比Lock优先被使用。

#### 可重入锁（synchronized和ReentrantLock都可重入）

- 优点：可以实现定时的锁等待，可以响应中断，也可以选择实现为公平/非公平锁。
- 缺点：使用有风险，如忘了在finally中释放，虽然代码能跑，但是埋下了“坑”。
- 使用场景：需要实现定时的锁等待，或者响应中断的场景。

#### volatile

- 优点：修饰的变量能读取到最新的数据，不需要切换到内核态，性能比synchronied和ReentrantLock好。
- 缺点：只能保证可见性，实现线程安全需要配合其他技术手段来保证原子性。
- 使用场景：适用于少于或等于一个线程写，多个线程读的场景，多线程写且多线程读的场景也可以配合CAS原子操作实现线程安全。