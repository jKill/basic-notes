## ElasticSearch 查询流程与分页
### 查询流程

- 解析请求，分析语法。
- 获取要访问的 Shard 列表。
- query 阶段：遍历列表，在每个 Shard 上查询数据。（ES 分区存储数据，查询时需要在所有 Shard 中查询）。
- fetch 阶段：数据合并，排序。并返回客户端。

ES 的检索分 query 和 fetch 两阶段。相对来说，query 阶段比较高效。
### 分页方式

- From + Size 查询
- Search After 查询
- Scroll 查询

#### From + Size 查询
功能上类似于 MySQL 的```limit```，因此同样存在深度翻页问题。适用于总页数不多的场景。

优点

- 使用简单。

缺点

- 受限于```max_result_window```（默认10000）不能无限制翻页。
- 深度翻页问题：翻页深度大时慢，且消耗内存大（页深度大时，需要从 ES 各节点聚合的数据也多）。

#### ```search_after``` 方案
使用前一页的**排序的唯一标识**检索下一页，适用于手机端这类只需要翻下一页的场景。MySQL 也有类似方案。

优点

- 可以无限制往后翻页，总页数不受```max_result_window```限制。
- 在仅仅”下一页“的场景下，深度翻页性能较好。

缺点

- 不支持随机翻页。

#### Scroll api 查询
首次查询时，会生成当前查询条件结果的快照。后面每次翻页都基于这个快照，后面即使有新的数据也不会被查询到。因此查询是非实时的，响应时间比 From + Size 和 ```search_after``` 长很多。适合需要遍历全量数据，并且实时性不高（如报表导出）的场景。

优点

- 全量遍历性能较好。

缺点：

- 查询非实时。
- 保留上下文需要足够的堆空间。
