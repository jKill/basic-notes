## 分布式数据-分布式系统的麻烦
### 网络拥塞和排队
网络上数据包延迟的可变性通常是由于排队。

- 如果有多个节点将数据包发往同一个目的地，网络交换机必须将它们排队并逐个送入目标网络链路。如果传入数据太多，交换机队列被填满，数据包会被丢弃。
- 数据包到达目标机器时，如果所有 CPU 内核都处于繁忙状态，那么请求会被操作系统排队。
- 虚拟化环境中，操作系统经常暂停几十毫秒，把 CPU 内核让给另一台虚拟机。这段时间，来自网络的数据包也会被虚拟机监视器排队。
- TCP 执行流量控制(flow control)（也叫拥塞避免(congestion avoidance)或背压(backpressure)），节点会限制自己的发送速率避免网络或接受节点过载，所以请求发送者也存在排队。

### 同步网络和异步网络
同步网络：

- 特性：预留带宽，电路建立时不允许其他人使用。
- 使用场景：电话网络。
- 优点：最大端到端延迟是固定的，即有限延迟（bounded delay）。
- 缺点：互联网场景中很难分配带宽，过高导致浪费，过低则可能传输缓慢。

异步网络：

- 特性：机会性使用任何可用带宽，尽可能快地传输数据包。
- 适用场景：互联网。
- 优点：针对突发流量（bursty traffic）进行了优化。TCP 连接空闲时不占用带宽。
- 缺点：延迟没有上限，会带来分布式系统的各种难题。

### 全局快照的同步时钟

- 有缺陷的解决方案：Twitter 的 Snowflake 算法可以实现一个**近似**单调递增的 ID 生成器，但是在多数据中心时无法保证因果顺序。（如较晚产生的事务，却更早到达了 ID 生成器所在的数据中心）。
- 更好的方案：Spanner 的 Google TrueTime API，会报告时钟的置信区间[最早，最晚]。如果两个事务的置信区间不重叠，显然能确定两个事务的先后顺序。只有重叠时才不确定它们的顺序。

### 进程暂停

- 虚拟机管理程序可能把当前虚拟机挂起（suspend，挂起进程并把内容保存到磁盘）。（如虚拟机实时迁移的时候，而不需要重启）。
- GC 带来的停顿。
- 同步 IO，可能在不主动调用的时候发生，如 Java 的类加载器在第一次使用时惰性加载类文件，可能在程序执行过程随时发生。
- 其他情况的突然停顿：如用户合上笔记本；收到 SIGSTOP 信号（shell 中按下 Ctrl-z 即可触发）。

### 响应时间保证（实时系统）
如上，进程和线程会因为各种原因暂停。但通过一定的 tradeoff，这些暂停也是可以消除的。需要各级软件栈的支持：

- 一个操作系统（RTOS），允许在指定时间间隔内保证 CPU 时间分配；
- 库函数必须记录下最坏时间复杂度的执行时间；
- 动态内存分配收到限制甚至被禁止（确保不会给 GC 带来太大负担）；
- 必须进行大量测试来保证实时效果。

### 防护令牌（fencing token）
可以通过 fencing token 来防止分布式环境下，被锁定资源遭到同时写入的情况。如获得锁的节点因为进程停顿，导致租约到期后（锁被其他节点获取了）才开始写入的情况。
### 拜占庭故障
在一个系统的节点故障、不遵守协议，甚至恶意攻击，扰乱网络时还能正常工作，称之为拜占庭容错（Byzantine-fault-tolerant）的。

- 自己的数据中心，节点都由自己控制，是可以信任的。
- 大多数服务端系统中，部署拜占庭容错解决方案的**成本过高，不切实际**。
- web 应用确实需要有恶意行为（如 SQl 注入，跨站脚本）的应对方案，但通常不适用拜占庭容错协议，而是让服务端决定什么是客户端行为，什么是被禁止的（输入验证、输出转义）。
