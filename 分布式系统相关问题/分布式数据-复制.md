## 分布式数据-复制
复制的作用：

- 系统高可用（包括部分节点故障和应用遇到网络中断）
- 可拓展性（处理比单个机器更多的请求）
- 减少延迟（让数据地理上更接近用户）

### 多主复制（多活、多 Leader）
通常是在多个数据中心场景使用：每个数据中心配置一个主库。带来的优势如下：

- 性能提升：每个写操作在本地数据中心处理，并与其他数据中心异步复制。（对用户来说，数据中心之间的网络延迟是透明的。）
- 容忍数据中心停机：单主配置，如主库所在数据中心故障，故障切换可以使另一个数据中心的 follower 成为 Leader。在多活配置中，每个数据中心独立于其他数据中心继续运行，故障的数据中心归队后，复制会自动赶上。
- 容忍网络问题：数据中心之间通过**公共互联网**，不如数据中心内的**本地网络**可靠。单主配置对数据中心间的连接问题非常敏感，因为需要通过这个连接同步写入。而多活使用异步复制，临时的网络中断不会妨碍写入。

但也有很明显的缺点：

- 不同的数据中心可能修改相同的数据，写冲突时必须解决的。
- 在许多数据库属于改装功能，常常存在微妙的配置缺陷：如自增主键、触发器、完整性约束等。常被认为是危险的领域，应尽可能避免。

#### 需要离线操作的客户端
多主复制的另一个使用场景：应用需要在断网之后正常使用。每个设备有一个充当 Leader 的本地数据库，与其他设备异步复制。这种架构实际上与多 Leader 复制类似，每个设备都是一个“数据中心”。
#### 协同编辑
实时协作编辑应用允许多人同时编辑文本，类似于多主复制，更改会立刻应用到本地副本，并异步复制到编辑同一文本的其他用户。最大的问题之一同样是写入冲突。

### 无主复制
客户端发送写入到几个节点，并从多个节点并行读取，能保证 w + r > n，通常能保证读取到的多个值中包含最新值。

### 写入冲突的解决方法（无主和多主架构会出现）

- 避免冲突：将特定记录的写入交给同一个 Leader 处理（如：路由到同一个 Leader）。
- 最后写入胜利（LWW,last write wins）：每个写入分配一个 ID。但是并发时容易丢失更新（向客户端报告成功，但是 ID 相对小的更新被静默丢弃）。
- “捕获”此前发生：每个键分配一个版本号，写入时只能覆盖版本更低的数据。虽然能保证不会覆盖，但是会导致 server 存在多个版本的值。
- 合并同时写入的值：在代码里合并并发写入的值，但是复杂而易错。所以像 Riak 的 CRDT 数据结构被设计出来专门自动处理这种合并。

### 读写的法定人数
#### 松散的法定人数（sloppy quorum）

- 通过临时写入 n 之外的节点，提高写入可用性。
- 但是不能保证读取到最新值。因此并不算是法定人数。

### 监控复制落后

- 基于 Leader 的复制：这类型的数据库通常会公开复制滞后的度量标准，我们可以将其提供给监控系统。
- 无 Leader 复制：这类型由于没有固定的写入顺序，监控非常难。

### “此前发生”关系和并发关系
判断标准：一个操作是否在另一个操作前发生，即两个操作是否有因果依赖关系。如果没有，就属于并发。两个操作 A 和 B 有三种可能性，A 在 B 之前发生，B 在 A 之前发生，或者 A 和 B 并发。

> 事实上，两个操作时间上是否重叠不重要，由于分布式系统发的时钟问题，现实中很难判断两个事件是否同时发生的。

### 单调读(Monotonic Read)
是一种比强一致性更弱，最终一致性更强的保证。常用来解决“时光倒流”问题（用户在一个副本读到了更新，第二次在另一个副本却读不到了）。常用的实现方法是用户将请求散列到固定的副本。