## 分布式数据-一致性与共识
构建容错系统的最好方法，是找到一些带有实用保证的通用抽象，实现一次，然后让应用依赖这些保证。如事务：通过使用事务，应用可以假装没有崩溃（原子性），没有其他人同时访问数据库（隔离），存储设备是完全可靠的（持久性）。即使发生崩溃，竞态条件和磁盘故障，事务抽象隐藏了这些问题，因此应用不必担心它们。
### 共识
分布式系统最重要的抽象之一就是共识（consensus）：让所有节点就某件事情达成一致。

> 共识的不可能性：FLP 结果证明：如果存在节点可能崩溃的风险，则不存在总是能达成共识的算法。**但是现实中的分布式系统通常是可以达成共识的**。

### 一致性
分布式一致性主要关于：面对延迟和故障，如何协调副本间的状态
#### 线性一致性
线性一致性：任何客户端都有相同的数据视图，且不必担心复制滞后。也称原子一致性（atomic consistency），强一致性（strong consistency）或外部一致性(external consistency)。

### 全序广播
全序广播（total order broadcast）通常被描述为在节点间交换消息的协议。通常要满足两个安全属性：

- 可靠交付（reliable delivery）：，没有消息丢失，如果被传到一个节点，它将被传到所有节点
- 全序交付（totally order delivery）：消息以相同的顺序传递给每个节点。

#### 其他特点

- 全序广播的一个重要特点是：顺序在消息送达时被固化。
- 异步：消息保证以固定的顺序可靠传送，但不保证何时送达。

#### 场景

- 像 Zookeeper 和 etcd 这样的共识服务实际上实现了全序广播。
- 复制日志、事务日志或预写式日志：所有节点都必须以相同的顺序传递相同的消息，所以所有节点都能看到相同的消息序列/日志。
- 对于实现带 fencing token 的锁服务也很有用：每个获取锁的请求都作为一条消息追加到日志末尾，并且按它们在日志中出现的顺序编号，序列号可以作为 fencing token 用，因为是单调递增的，在 Zookeeper 中，这个序列号被称为 Zxid。

### 两阶段提交
通过协调者节点和分支事务参与者的通信和日志记录，实现整个分布式事务的状态转移和崩溃恢复。
#### 缺点

- 在协调者做出提交/回滚决定前，协调者崩溃会导致事务参与者一直处于等待状态。
- 事务参与者等待期间一直锁定目标数据（保证没有主键冲突、脏写等），导致阻塞。
- 如果协调者没有副本，还会有单点风险。

### 三阶段提交
两阶段提交作为阻塞的原子提交协议，因为存在可能卡主等待协调者恢复的情况。作为 2PC 的替代方案，三阶段提交引入了超时机制。
#### 缺点

- 在现实系统往往不能保证原子性，因为网络延迟和进程停顿的时间上界无法预估。

### 实践中的分布式事务
报告称：MySQL 的分布式事务比单节点事务慢10倍以上。两阶段提交固有的性能成本，大部分是崩溃恢复所需要的强制刷盘和网络往返。
### XA 事务

- X/Open XA（扩展架构（eXtended Architecture）的缩写）是跨异构技术实现两阶段提交的标准。
- 许多传统关系数据库（包括 PostgreSQL，MySQL 和 Oracle）和消息代理（包括 ActiveMQ） 都支持 XA。
- 事务协调者需要实现 XA API。实际上协调者通常只是一个库，被加载到发起事务的应用的同一个进程中（而不是单独的服务）。使用本地磁盘上的日志记录每次事务的决定（提交/中止）。

#### 缺点

- 数据库服务器不能直接联系协调者，因为所有通信都必须通过客户端库。

### 容错共识

- 如果所有的节点都崩溃了，没有一个在运行，那么所有算法都不可能决定任何事情。算法可以容忍的失效数量是有限的：事实上可以证明，任何共识算法都需要至少占总体多数（majority）的节点正确工作。
- 大多数共识算法假设不存在拜占庭式错误。

### 共识的优缺点
优点：

- 为不确定性的系统带来安全属性（一致同意，完整性和有效性）。
- 容错：只要多数节点正常且可达，就能取得进展。

缺点：

- 节点对提议投票是一种同步复制，数据库往往配置成异步复制，在故障切换过程可能会丢失数据。
- 总是需要严格多数运转，如果网络切断了某些节点和其他节点的连接，只有多数节点所在的网络能正常工作。
- 共识系统依靠超时检测节点失效，在地理上散部的系统中，经常发生一个节点由于暂时的网络问题，以为 Leader 已经失效。产生频繁的 Leader 选举，导致性能糟糕。

### 共识应用场景

- 线性一致性的CAS寄存器：寄存器需要基于当前值是否等于操作给出的参数，**原子**地决定是否设置新值。
- 原子事务提交：数据库必须决定是否提交或中止分布式事务。
- 全序广播：消息系统必须决定传递消息的顺序。
- 锁和租约：当几个客户端争抢锁或租约时，由锁来决定哪个客户端成功获得锁。
- 成员/协调服务：给定某种故障检测器（例如超时），系统必须决定哪些节点活着，哪些节点因为会话超时需要被宣告死亡。

### 服务发现
etcd 和 Zookeeper 和 Consul 也经常用于服务发现。**但是，服务发现是否需要达成共识尚不清楚**——用于查找服务名和 IP 地址的 DNS 就是典型的最终一致性。

- DNS 通过多层缓存实现良好的性能和可用性。
- DNS 查询结果过时通常不会有问题，DNS 的可用性和对网络中断的鲁棒性更重要。