## Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

### 如何判断对象需要回收
判断对象是否存活，主流的方法有引用计数法和可达性分析：

#### 引用计数法
有一个地方引用，计数器+1；引用失效时，计数器减一。

- 优点：原理简单，判定效率也高。
- 缺点：无法解决循环引用。因此Java使用的是可达性分析而不是它。

#### 可达性分析
以一系列可作为“GC Root”的对象为起点，根据引用链向下搜索，在引用链上的对象均为可达对象；反之，通过这些引用链无法达到的对象为不可达对象，需要被回收。

- 优点：可以解决循环引用。
- 缺点：比引用计数法复杂。

GC Root包括：

- 虚拟机栈引用的对象；
- 本地方法栈中JNI引用的对象；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象。
- 所有被同步锁(synchronized关键字)持有的对象。
- JVM内部的引用，如基本数据类型对应的Class对象，系统类加载器等。

### 常见的GC算法

#### 标记-清除
标记出需要回收的对象，然后统一回收被标记的对象。也可以反过来，标记存活的对象，然后统一回收未被标记的对象。
#### 优点

- 不需要移动存活对象（移动存活对象必须Stop the world，影响性能）。

#### 缺点

- 执行效率不稳定：如果堆中大多数对象是需要回收的，那么就要进行大量标记和清理动作。
- 会产生内存碎片：回收对象后，不连续的内存可能导致没有足够的空间分配对象，提前触发另一次GC。

#### 适用场景
与标记-整理配合使用：即平时使用**标记-清除**，内存碎片多了以后使用一次**标记-整理**。CMS收集器就是用这种方法整理内存碎片，

#### 标记-复制
把内存分为两块，只在其中一块分配对象，回收时把存活对象复制到另一块，然后清除原来的内存区域。
#### 优点

- 一次性清理整个半区，不会产生内存碎片；
- 实现简单，只需移动堆顶指针顺序分配，运行高效。
- 对于少量对象存活的区域，只需复制少量的对象。

#### 缺点：

- 空间浪费：可用内存缩小了一半。“Appel式回收”改进成8:1:1的一块Eden和两块Survivor区域之后，也还是有1/10的浪费。
- 需要分配担保：Survivor不足以容纳一次Minor GC后的存活对象时，需要通过分配担保让对象进入老年代。

#### 适用场景
适合在对象存活时间短的新生代使用，如JVM进行Minor GC时，会将eden区和其中一个survivor区的存活对象复制到另一个survivor区。
#### 标记-压缩
可达性分析找出存活对象，移动到内存区域的一边，然后清除另一边的区域。能得到更规整的内存空间。
#### 优点

- 不会产生内存碎片，有利于提升对象分配的效率。

#### 缺点

- 需要移动存活对象，降低回收的效率。

### 标记-清除与标记-整理的对比和权衡
标记-清除和标记-整理都有标记对象的过程，区别在于是否移动存活的对象。

- 这个操作优点在于可以得到规整的内存空间。方便分配对象。
- 缺点则是移动对象是一个比较重的操作，需要STW。
- 但是由于内存分配和访问比垃圾收集的频率高得多，移动对象更划算。

### 空间分配担保
在进行 **Minor GC** 前，如果老年代可用连续空间不足，小于新生代对象大小总和。在同时满足以下两个条件时，会发生空间分配担保，“冒险”用 Minor GC 代替 Full GC：

- JVM 参数 ```-XX:HandlePromotionFailure``` 设置允许冒险。
- 老年代可用连续空间大于历次晋升到老年代对象的平均大小。