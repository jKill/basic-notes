## Java 常见锁有哪些？ReetrantLock 是怎么实现的
Java常见的锁，从不同的角度可以分为以下几种：

- 悲观锁/乐观锁
- 自旋锁/适应性自旋锁
- 可重入锁
- 公平锁/非公平锁
- 独占锁/共享锁

#### 悲观锁/乐观锁
- 对于一个数据并发操作，悲观锁认为在使用数据时一定会有其他线程来修改数据，在获取数据前会加锁。Java的synchronized和Lock都属于悲观锁；
- 乐观锁则在更新数据前才会检查数据有没有被其他线程更新，如果没有则成功写入数据，有的话根据具体实现重试或者返回获取失败。

#### 可重入锁
Java的synchronized和Lock都是可重入的，已经获得锁的线程再次进入同步区域会自动获得锁。

#### 自旋锁/自适应自旋锁
- 通过CAS操作在循环不断检查数据状态，根据数据是否被修改决定重试或者其他策略，可以实现自旋锁；Java中的实现有JUC包中的AtomicInteger等原子类，都是通过自旋锁实现线程安全的。
- 自适应自旋锁则在自旋锁的基础上做了进一步优化，可以根据之前的自旋结果来改变并发策略，而不是一味地自旋。如果之前的自旋结果经常失败（数据被修改），则认为这次很可能也会失败，不再自旋而直接阻塞线程，避免过多无效的自旋浪费CPU时间。

### ReentrantLock 的实现
- ReentrantLock基于AQS实现线程安全，核心是继承了AQS的Sync类，通过实现AQS的acquire()和release()方法实现lock()和unlock()。
- 使用AQS的volatile int state记录当前同步状态，0表示没有锁定；>0的时候表示被锁定，此时state的值表示锁重入的次数。
- 使用AQS的volatile int waitStatus记录任务在队列的状态。
- 默认实现为非公平锁，通过Sync的子类NonFairSync实现，新任务会先尝试”插队“，CAS把state改为1，修改成功则拿到锁；公平锁底层实现为FairSync，队列节点严格遵循先进先出。
- 相对synchronized，Lock可以通过lockInterruptibly()方法以响应中断的方式获取锁。

#### 获取锁的流程（非公平独占模式）

- 1、先CAS尝试把state修改为1（插队），成功则拿到锁（标记AQS的独占线程```exclusiveOwnerThread```为当前线程）返回；
- 2、失败则CAS把节点添加到等待队列（双向链表）尾部等待；
- 3、开始一个死循环：在如果前驱节点是头节点（头节点代表已获得锁的线程），则CAS修改state尝试获取锁，成功（说明头节点已用完锁并释放）则结束死循环返回；
- 4、否则根据上一个节点的waitStatus决定是否挂起当前挂起线程，然后继续死循环的下一轮。
