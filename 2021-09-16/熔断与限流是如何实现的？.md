## 熔断与限流是如何实现的？
### 熔断如何实现
熔断器的工作状态分为打开、半打开、关闭。正常状态下是关闭的。

- 调用方调用下游服务异常时，熔断器会收集异常信息。到达熔断条件时拦截请求，并快速执行失败逻辑。
- 经过一段时间后，熔断器尝试转为半打开状态，这时熔断器允许通过一个请求，如果这个请求成功了，熔断器转为关闭。否则恢复打开状态。

### Sentinel 熔断的降级策略

- 平均响应时间：如果1s内的平均响应时间超过阈值，那么在接下来的时间窗口内，对这个方法的调用会触发熔断/执行降级策略。
- 异常比例：1s内请求异常比例超过阈值后，熔断/执行降级策略。
- 异常数：1分钟内异常请求数超过阈值后，熔断/执行降级策略。

### 限流如何实现
可以分为两大类，客户端限流和服务端限流。客户端限流主要包括前端的防重复点击按钮、验证答题等。服务端限流有滑动窗口、令牌桶、漏桶算法等。

#### 时间窗口
时间窗口内请求数量达到阈值，丢弃请求。分固定窗口和滑动窗口。固定窗口可以用 Redis 的```INCR```和```DECR```命令实现。

- 固定窗口：一段时间内请求数量超过阈值，拒绝后面的请求。缺点是容易在时间段边界附近产生流量高峰。
- 滑动窗口：**任意**一段时间内请求数量超过阈值，拒绝后面请求。解决了固定窗口在时间段边界的流量高峰问题。

#### 漏桶算法

- 水（请求）从桶上方进入桶内，从下方以恒定速度漏出（被处理）。
- 来不及漏出的水在桶内（缓冲），水满后溢出（丢弃）。

可通过 Redis 的 LIST 数据结构实现。把请求放入队列，消费这以恒定速度从队列取出请求并处理。
#### 令牌桶算法

- 以恒定速度向桶内放令牌，请求到来时，从桶内拿到令牌才能被处理。
- 桶被放满后，多余的令牌会溢出。

也可通过 Redis 的 LIST 数据结构实现。以恒定速度往队列里放令牌，消费者从队列里取令牌，然后处理请求。
#### 漏桶和令牌桶算法区别

- 漏桶算法：限制请求处理速度。
- 令牌桶算法：限制请求处理速度，还允许一定程度的突发流量。

### 业界常用限流框架比较
#### Hystrix：

- 采用线程池隔离资源。
- 记录请求成功、失败、超时或线程池拒绝。达到阈值触发 fallback 降级

#### Hystrix getFallback() 降级触发情况

- run() 方法抛出异常或超时。
- 熔断器开启拦截。
- 线程池/队列满了。

#### Hystrix 优劣分析

- 隔离彻底。
- 线程切换较多，并且需要提前给各资源分配线程池大小。

#### Sentinel
可以对线程池并发数进行限制，还可以通过响应时间进行快速降级。依赖度资源出现响应时间过长之后，新请求会被拒绝，需要经过指定的时间窗口才恢复。
#### Sentinel 优劣分析

- 没有Hystrix线程池隔离得彻底，但是通过并发数限制减少了线程切换开销。
- 提供系统维度的保护，防止雪崩。集群下，某台机器高负载会导致请求被转发到集群内其他机器上，如果其他机器也处于高负载的边缘状态，会导致其他机器相继崩溃，最后整个集群大面积崩溃。
