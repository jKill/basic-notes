## HashMap 实现原理，为什么使用红黑树？

### HashMap原理相关

- 特性：HashMap是可以在O(1)时间复杂度内实现实现查找，插入（不考虑扩容），删除操作的数据结构
- 数据结构：具体实现为通过对插入的key进行hash，分配到内部的Node数组不同的位置，Node底层为链表或红黑树
- hash冲突解决：不同的key如果hash到相同的数组下标，即发生hash冲突，会通过”尾插法“（JDK1.7之前使用”头插法“）把节点插入到原来的链表上，并且在链表长度达到8，而且数组长度也达到64时，会转化为红黑树，如果红黑树节点减少到6，重新恢复成链表。
- 扩容：在HashMap大小达到阈值（根据负载因子计算）时，进行扩容，扩容后为原来的两倍大小。hash值的计算依赖数组长度，所以扩容后要重新计算元素下标。

### 使用红黑树的原因
#### 相比普通二叉排序树
二叉排序树BST具有左子树所有节点小于根节点的特性，如果添加的节点都越来越小或者越来越大，会导致树往一边”倾斜“，退化成链表。失去了使用树形数据结构的意义。
#### 相比AVL树

- AVL追求更严格的平衡，所以查找速度更快；
- 但在插入和删除节点的时候，需要比红黑树更多地旋转次数来保持平衡，旋转时间复杂度O(n)。
- 而红黑树通过配合变色，可以在常数时间内完成旋转，旋转时间复杂度O(1)。此外，红黑树的实现和调试也比AVL树容易。所以，红黑树的通用性更好。