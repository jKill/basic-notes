##简述 MySQL MVCC 的实现原理
MySQL的4个隔离级别：读未提交，读提交，可重复读，串行化。事务的隔离就是通过MVCC（multiversion concurrency control，多版本并发控制）实现的。举个例子，有这样的一张表，按时间顺序执行以下两个事务：

```
mysql> create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

|事务A|事务B|
|:--|:--|
|启动事务，查询得到值1|启动事务|
||查询得到值1|
||将1改成2|
|查询得到值V1||
||提交事务B|
|查询得到值V2||
|提交事务A||
|查询得到值V3||

在不同的隔离隔壁级别下，事务A会有不同的返回结果，也就是V1、V2、V3会得到不同的值。

- 如果隔离级别为读未提交，V1的值是2，**因为事务B虽然没提交，但是已经被A看到了**，因此，V2，V3的值也都是2。
- 如果隔离级别为读提交，V1的值是1，**事务B的更新在提交后才能被A看到**，所以V2，V3的值是2。
- 如果隔离级别是可重复读，V1，V2的值都是1，V3时。之所以V2还是1，**就是因为遵循了这个要求：事务在执行期间看到的数据必须是前后一致的**。
- 如果隔离级别为串行化，在事务B执行“将1改成2”的时候，会被锁住。直到A提交后，才能继续执行。所以在A看来，V1，V2是1，V3是2。

### MVCC的实现原理
在实现上，数据库会创建一个视图，访问的时候以视图的逻辑结果为准。这个视图就是InnoDB在实现MVCC用到的一致性读视图，即consistent read view。

- 在“可重复读”级别下，这个视图是在启动时创建的，整个事务存在期间都用这个视图。
- 在“读提交”级别下，这个视图是在每个SQL语句开始执行时创建的。
- “读未提交”级别下直接返回记录上的最新值，**没有视图概念**。
- “串行化”级别，直接用加锁的方式避免并行访问。

InnoDB在内部为每一行添加了三个字段：

- DB_TRX_ID，是一个6字节的事务标识符，标识了最近一个影响了这一行的事务（包括插入、更新、删除）。
- DB_ROLL_PTR，是一个7字节的滚动指针（roll pointer）。滚动指针指向被写到回滚段（rollback segment）里的undo log。如果这行被更新了，可以在undo log里找到更新之前的数据信息，能把数据恢复到更新前。
- DB_ROW_ID，一个6字节的字段，包含严格递增的row ID，DB_ROW_ID只会出现在聚簇索引，而不会出现在其他索引中。

#### insert和update的undo logs
回滚段里的undo log分成insert的undo logs和update的undo logs。

- insert的undo log只用在事务回滚上，可以在事务提交后马上清理，方便释放内存。
- update的undo log还会用在一致性读上，所以只要有活跃的事务需要用到undo里的信息，来构建更早的数据版本。update的undo logs就不能被清理。

因此，MySQL推荐你定时提交事务。否则InnoDB无法清理update的undo logs，导致回滚段越来越大，填满undo表空间。undo log的物理大小通常小于其对应的insert或update的数据行，你可以通过这个信息计算回滚段需要的空间。